#!/usr/bin/env bash

# git-stagelight
# https://github.com/hyperfekt/git-stagelight
# version 1.1.0

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.



set -e

# used to remember previously seen unstaged files
previousfile=".git/info/stagelight"
# git's local equivalent of .gitignore
excludefile=".git/info/exclude"

# gain access to stdin - git hooks aren't interactive by default
exec < /dev/tty

function print {
    printf "%s" "$1"
}

function descend {
    # git ls-files -o --directory shows only a directory only if all files in it or its subfolders are unstaged
    # ergo if there is more than one file in it, they are all unstaged, but if there is only one we should just show that instead
    if [[ -d "$1" && ! -L "$1" ]]; then
        mapfile -d '' -t inner < <(stdbuf -oL git ls-files -o -z --directory --no-empty-directory --exclude-standard --exclude-from="$previousfile" "$1/" | head -z -n 2)
        if [[ ${#inner[@]} -eq 1 ]]; then
            descend "${inner[0]}"
        else
            printf "%s\0" "$1/"
        fi
    else
        printf "%s\0" "$1"
    fi
}

function uniquedir {
    if [[ "$1" == "." ]]; then
        depth=0
    else
        mapfile -d '/' -t depth <<< "$1"
        let depth=${#depth[@]}-1
    fi
    while read -d '' -r path; do
        if [[ ! -v prevcommon[@] ]]; then
            mapfile -d '/' -t prevcommon < <(print "$path")
        else
            mapfile -d '/' -t components < <(print "$path")
            if [[ ${prevcommon[$depth]} == ${components[$depth]} ]]; then
                let i=$depth+1
                # git ls-files always returns files in folders before files in their subfolders, meaning $prevcommon never has more path elements than the current path
                while [[ $i -lt $lencommon && "${prevcommon[$i]}" == "${components[$i]}" ]]; do
                    let i+=1
                done
                prevcommon="${prevcommon[@]:0:$i}"
                lencommon=$i
            else
                # output previously found most common path
                IFS='/'; descend "${prevcommon[*]}"
                # start anew with full path
                mapfile -d '/' -t prevcommon < <(print "$path")
                lencommon=${#prevcommon[@]}
            fi
        fi
    done < <(stdbuf -oL git ls-files -o -z --directory --no-empty-directory --exclude-standard --exclude-from="$previousfile" "$1")
    IFS='/'; descend "${prevcommon[*]}"
}

function truncate {
    IFS=';'; read -sdR -p $'\E[6n' ROW COL
    termwidth=$(tput cols)
    if [[ -z $2 ]]; then
        buffer=0
    else
        buffer=$2
    fi
    length=$(($termwidth-$COL-$buffer+1))
    print "$1" | awk -v len="$length" 'BEGIN { RS = "\0" } { if (length($0) > len) printf("%s%s", substr($0, 1, len-1), "…"); else printf("%s", $0); }'
}

function list {
    tput sc
    # leave enough space for '  contains: '
    contents="$(truncate "$(cd "$1"; uniquedir "." | tr '\0' ' ' | head -c $((4*$(tput cols))))" 12)"
    print "  contains: $contents"
    tput rc
}

function discard {
    kill $contains 2>/dev/null || true
    wait $contains 2>/dev/null || true
    kill $enter 2>/dev/null || true
    wait $enter 2>/dev/null || true
}

function escape {
    awk 'BEGIN { RS = "\0" } { printf("%s", gensub(/[^[:alnum:]]/, "\\\\&", "g", $0))}' < <(print "$1")
}

function prompt {
    while read -u 3 -d '' -r path; do
        tput civis
        if [[ -d "$path" && ! -L "$path" ]]; then
            # leave enough space for ' █ contains: x…'
            truncate "$path" 15
            print " "
            list "$path" <&0 &
            contains=$!
            buffer=$(mktemp) && returncode=$? || returncode=$?
            if [[ returncode -eq 0 ]]; then
                exec 5<$buffer
                exec 6>$buffer
                rm $buffer
                uniquedir "$path" >&6 &
                enter=$!
            fi
        else
            # leave enough space for ' excluded.'
            truncate "$path" 10
            print " "
        fi
        tput cnorm
        while true; do
            stty -echo
            read -n 1 -r
            stty echo
            if [[ "$REPLY" == "s" ]]; then
                discard
                tput el
                git ls-files -o -z --exclude-standard --exclude-from="$previousfile" "$path" | git update-index --add -z --stdin
                echo "staged."
                break
            elif [[ "$REPLY" == "o" ]]; then
                discard
                tput el
                echo -n "/$(escape "$path")" >> "$previousfile"
                echo "omitted."
                break
            elif [[ "$REPLY" == "e" ]]; then
                discard
                tput el
                echo "/$(escape "$path")" >> "$excludefile"
                echo "excluded."
                break
            elif [[ -z "$REPLY" && -d "$path" && ! -L "$path" ]]; then
                kill $contains 2>/dev/null || true
                wait $contains 2>/dev/null || true
                tput el
                tput civis
                printf "\r"
                prompt 3<&5
                break
            fi
        done
    done
}

function ul {
    printf "\e[4m%s\e[0m" "$1"
}

touch "$previousfile"
touch "$excludefile"
# wait for only one line, fast abort
if [[ -n "$(stdbuf -oL git ls-files -o --directory --no-empty-directory --exclude-standard --exclude-from="$previousfile" "." | head -n 1)" ]]; then
    echo "New unstaged files ($(ul s)tage, $(ul o)mit, $(ul e)xclude, or ↵ to enter directory):"
    prompt 3< <(uniquedir ".")
    mapfile -td '' cmd < <(cat /proc/$PPID/cmdline)
    eval "${cmd[@]}"
    result=$?
    if command -v gdb >/dev/null; then
        gdb --batch --eval-command "call (void)exit($result)" --pid $PPID >/dev/null 2>/dev/null
    else
        if [[ $result -eq 0 ]]; then
            echo -n "commit successful, ignore exit code (install gdb to exit with 0 instead)" >&2
        else
            echo "commit failed with exit code $result" >&2
        fi
        exit 1
    fi
fi
